import numpy as np
import matplotlib.pyplot as plt
import os

class SeismicCPML2DAniso:
    def __init__(self):
        # Grid parameters
        self.NX = 401
        self.NY = 401
        
        # Grid spacing
        self.DELTAX = 0.0625e-2
        self.DELTAY = self.DELTAX
        
        # PML flags and parameters  
        self.USE_PML_XMIN = True
        self.USE_PML_XMAX = True
        self.USE_PML_YMIN = True
        self.USE_PML_YMAX = True
        self.NPOINTS_PML = 10
        
        # Material properties (Model I from Becache, Fauqueux and Joly)
        self.scale_aniso = 1.0e10
        self.c11 = 4.0 * self.scale_aniso
        self.c12 = 3.8 * self.scale_aniso  
        self.c22 = 20.0 * self.scale_aniso
        self.c33 = 2.0 * self.scale_aniso
        self.rho = 4000.0
        self.f0 = 200.0e3
        
        # Time stepping parameters
        self.NSTEP = 3000
        self.DELTAT = 50.0e-9
        
        # Source parameters
        self.t0 = 1.20/self.f0
        self.factor = 1.0e7
        self.ISOURCE = self.NX // 2
        self.JSOURCE = self.NY // 2
        self.xsource = (self.ISOURCE - 1) * self.DELTAX
        self.ysource = (self.JSOURCE - 1) * self.DELTAY
        self.ANGLE_FORCE = 0.0
        
        # Display parameters
        self.IT_DISPLAY = 100
        
        # Constants
        self.PI = np.pi
        self.DEGREES_TO_RADIANS = self.PI / 180.0
        self.ZERO = 0.0
        self.HUGEVAL = 1.0e+30
        self.STABILITY_THRESHOLD = 1.0e+25
        
        # PML parameters
        self.NPOWER = 2.0
        self.K_MAX_PML = 1.0
        self.ALPHA_MAX_PML = 2.0 * self.PI * (self.f0/2.0)
        
        # Initialize arrays
        self.initialize_arrays()
        
    def initialize_arrays(self):
        """Initialize all the arrays needed for the simulation"""
        # Main field arrays
        self.vx = np.zeros((self.NX, self.NY))
        self.vy = np.zeros((self.NX, self.NY))
        self.sigmaxx = np.zeros((self.NX, self.NY))
        self.sigmayy = np.zeros((self.NX, self.NY))
        self.sigmaxy = np.zeros((self.NX, self.NY))
        
        # Memory variables for PML
        self.memory_dvx_dx = np.zeros((self.NX, self.NY))
        self.memory_dvx_dy = np.zeros((self.NX, self.NY))
        self.memory_dvy_dx = np.zeros((self.NX, self.NY))
        self.memory_dvy_dy = np.zeros((self.NX, self.NY))
        self.memory_dsigmaxx_dx = np.zeros((self.NX, self.NY))
        self.memory_dsigmayy_dy = np.zeros((self.NX, self.NY))
        self.memory_dsigmaxy_dx = np.zeros((self.NX, self.NY))
        self.memory_dsigmaxy_dy = np.zeros((self.NX, self.NY))
        
        # 1D arrays for damping profiles
        self.d_x = np.zeros(self.NX)
        self.d_x_half = np.zeros(self.NX)
        self.K_x = np.ones(self.NX)
        self.K_x_half = np.ones(self.NX)
        self.alpha_x = np.zeros(self.NX)
        self.alpha_x_half = np.zeros(self.NX)
        self.a_x = np.zeros(self.NX)
        self.a_x_half = np.zeros(self.NX)
        self.b_x = np.zeros(self.NX)
        self.b_x_half = np.zeros(self.NX)
        
        self.d_y = np.zeros(self.NY)
        self.d_y_half = np.zeros(self.NY)
        self.K_y = np.ones(self.NY)
        self.K_y_half = np.ones(self.NY)
        self.alpha_y = np.zeros(self.NY)
        self.alpha_y_half = np.zeros(self.NY)
        self.a_y = np.zeros(self.NY)
        self.a_y_half = np.zeros(self.NY)
        self.b_y = np.zeros(self.NY)
        self.b_y_half = np.zeros(self.NY) 
        
    def setup_pml_boundary(self):
        """Setup the PML boundary conditions"""
        
        # Check stability of PML model for anisotropic material
        aniso_stability_criterion = ((self.c12 + self.c33)**2 - self.c11*(self.c22-self.c33)) * \
                                   ((self.c12 + self.c33)**2 + self.c33*(self.c22-self.c33))
        print(f'PML anisotropy stability criterion from Becache et al. 2003 = {aniso_stability_criterion}')
        if aniso_stability_criterion > 0.0 and (self.USE_PML_XMIN or self.USE_PML_XMAX or 
                                              self.USE_PML_YMIN or self.USE_PML_YMAX):
            print('WARNING: PML model mathematically intrinsically unstable for this anisotropic material for condition 1')
        
        aniso2 = (self.c12 + 2*self.c33)**2 - self.c11*self.c22
        print(f'PML aniso2 stability criterion from Becache et al. 2003 = {aniso2}')
        if aniso2 > 0.0 and (self.USE_PML_XMIN or self.USE_PML_XMAX or 
                             self.USE_PML_YMIN or self.USE_PML_YMAX):
            print('WARNING: PML model mathematically intrinsically unstable for this anisotropic material for condition 2')
        
        aniso3 = (self.c12 + self.c33)**2 - self.c11*self.c22 - self.c33**2
        print(f'PML aniso3 stability criterion from Becache et al. 2003 = {aniso3}')
        if aniso3 > 0.0 and (self.USE_PML_XMIN or self.USE_PML_XMAX or 
                             self.USE_PML_YMIN or self.USE_PML_YMAX):
            print('WARNING: PML model mathematically intrinsically unstable for this anisotropic material for condition 3')
        
        # Calculate quasi_cp_max for d0 computation and stability estimate
        quasi_cp_max = max(np.sqrt(self.c22/self.rho), np.sqrt(self.c11/self.rho))
        
        # Define profile of absorption in PML region
        thickness_PML_x = self.NPOINTS_PML * self.DELTAX
        thickness_PML_y = self.NPOINTS_PML * self.DELTAY
        
        # Reflection coefficient
        Rcoef = 0.001
        
        # Check NPOWER
        if self.NPOWER < 1:
            raise ValueError('NPOWER must be greater than 1')
        
        # Compute d0
        d0_x = -(self.NPOWER + 1) * quasi_cp_max * np.log(Rcoef) / (2.0 * thickness_PML_x)
        d0_y = -(self.NPOWER + 1) * quasi_cp_max * np.log(Rcoef) / (2.0 * thickness_PML_y)
        
        print(f'd0_x = {d0_x}')
        print(f'd0_y = {d0_y}')
        
        # Setup damping profiles
        xoriginleft = thickness_PML_x
        xoriginright = (self.NX-1)*self.DELTAX - thickness_PML_x
        
        # Damping in X direction
        for i in range(self.NX):
            xval = self.DELTAX * i
            
            # Left edge
            if self.USE_PML_XMIN:
                # Grid points
                abscissa_in_PML = xoriginleft - xval
                if abscissa_in_PML >= 0.0:
                    abscissa_normalized = abscissa_in_PML / thickness_PML_x
                    self.d_x[i] = d0_x * abscissa_normalized**self.NPOWER
                    self.K_x[i] = 1.0 + (self.K_MAX_PML - 1.0) * abscissa_normalized**self.NPOWER
                    self.alpha_x[i] = self.ALPHA_MAX_PML * (1.0 - abscissa_normalized)
                
                # Half grid points
                abscissa_in_PML = xoriginleft - (xval + self.DELTAX/2.0)
                if abscissa_in_PML >= 0.0:
                    abscissa_normalized = abscissa_in_PML / thickness_PML_x
                    self.d_x_half[i] = d0_x * abscissa_normalized**self.NPOWER
                    self.K_x_half[i] = 1.0 + (self.K_MAX_PML - 1.0) * abscissa_normalized**self.NPOWER
                    self.alpha_x_half[i] = self.ALPHA_MAX_PML * (1.0 - abscissa_normalized)
            
            # Right edge
            if self.USE_PML_XMAX:
                # Grid points
                abscissa_in_PML = xval - xoriginright
                if abscissa_in_PML >= 0.0:
                    abscissa_normalized = abscissa_in_PML / thickness_PML_x
                    self.d_x[i] = d0_x * abscissa_normalized**self.NPOWER
                    self.K_x[i] = 1.0 + (self.K_MAX_PML - 1.0) * abscissa_normalized**self.NPOWER
                    self.alpha_x[i] = self.ALPHA_MAX_PML * (1.0 - abscissa_normalized)
                
                # Half grid points
                abscissa_in_PML = xval + self.DELTAX/2.0 - xoriginright
                if abscissa_in_PML >= 0.0:
                    abscissa_normalized = abscissa_in_PML / thickness_PML_x
                    self.d_x_half[i] = d0_x * abscissa_normalized**self.NPOWER
                    self.K_x_half[i] = 1.0 + (self.K_MAX_PML - 1.0) * abscissa_normalized**self.NPOWER
                    self.alpha_x_half[i] = self.ALPHA_MAX_PML * (1.0 - abscissa_normalized)
            
            # Ensure alpha values are non-negative
            self.alpha_x[i] = max(self.alpha_x[i], 0.0)
            self.alpha_x_half[i] = max(self.alpha_x_half[i], 0.0)
            
            # Calculate b coefficients
            self.b_x[i] = np.exp(-(self.d_x[i] / self.K_x[i] + self.alpha_x[i]) * self.DELTAT)
            self.b_x_half[i] = np.exp(-(self.d_x_half[i] / self.K_x_half[i] + self.alpha_x_half[i]) * self.DELTAT)
            
            # Calculate a coefficients
            if abs(self.d_x[i]) > 1.0e-6:
                self.a_x[i] = self.d_x[i] * (self.b_x[i] - 1.0) / (self.K_x[i] * (self.d_x[i] + self.K_x[i] * self.alpha_x[i]))
            if abs(self.d_x_half[i]) > 1.0e-6:
                self.a_x_half[i] = self.d_x_half[i] * (self.b_x_half[i] - 1.0) / \
                                  (self.K_x_half[i] * (self.d_x_half[i] + self.K_x_half[i] * self.alpha_x_half[i])) 

    def setup_pml_boundary_y(self):
        """Setup the PML boundary conditions for Y direction"""
        
        # Calculate parameters for Y direction PML
        thickness_PML_y = self.NPOINTS_PML * self.DELTAY
        Rcoef = 0.001
        quasi_cp_max = max(np.sqrt(self.c22/self.rho), np.sqrt(self.c11/self.rho))
        d0_y = -(self.NPOWER + 1) * quasi_cp_max * np.log(Rcoef) / (2.0 * thickness_PML_y)
        
        yoriginbottom = thickness_PML_y
        yorigintop = (self.NY-1)*self.DELTAY - thickness_PML_y
        
        # Setup damping in Y direction
        for j in range(self.NY):
            yval = self.DELTAY * j
            
            # Bottom edge
            if self.USE_PML_YMIN:
                # Grid points
                abscissa_in_PML = yoriginbottom - yval
                if abscissa_in_PML >= 0.0:
                    abscissa_normalized = abscissa_in_PML / thickness_PML_y
                    self.d_y[j] = d0_y * abscissa_normalized**self.NPOWER
                    self.K_y[j] = 1.0 + (self.K_MAX_PML - 1.0) * abscissa_normalized**self.NPOWER
                    self.alpha_y[j] = self.ALPHA_MAX_PML * (1.0 - abscissa_normalized)
                
                # Half grid points
                abscissa_in_PML = yoriginbottom - (yval + self.DELTAY/2.0)
                if abscissa_in_PML >= 0.0:
                    abscissa_normalized = abscissa_in_PML / thickness_PML_y
                    self.d_y_half[j] = d0_y * abscissa_normalized**self.NPOWER
                    self.K_y_half[j] = 1.0 + (self.K_MAX_PML - 1.0) * abscissa_normalized**self.NPOWER
                    self.alpha_y_half[j] = self.ALPHA_MAX_PML * (1.0 - abscissa_normalized)
            
            # Top edge
            if self.USE_PML_YMAX:
                # Grid points
                abscissa_in_PML = yval - yorigintop
                if abscissa_in_PML >= 0.0:
                    abscissa_normalized = abscissa_in_PML / thickness_PML_y
                    self.d_y[j] = d0_y * abscissa_normalized**self.NPOWER
                    self.K_y[j] = 1.0 + (self.K_MAX_PML - 1.0) * abscissa_normalized**self.NPOWER
                    self.alpha_y[j] = self.ALPHA_MAX_PML * (1.0 - abscissa_normalized)
                
                # Half grid points
                abscissa_in_PML = yval + self.DELTAY/2.0 - yorigintop
                if abscissa_in_PML >= 0.0:
                    abscissa_normalized = abscissa_in_PML / thickness_PML_y
                    self.d_y_half[j] = d0_y * abscissa_normalized**self.NPOWER
                    self.K_y_half[j] = 1.0 + (self.K_MAX_PML - 1.0) * abscissa_normalized**self.NPOWER
                    self.alpha_y_half[j] = self.ALPHA_MAX_PML * (1.0 - abscissa_normalized)
            
            # Calculate b and a coefficients
            self.b_y[j] = np.exp(-(self.d_y[j] / self.K_y[j] + self.alpha_y[j]) * self.DELTAT)
            self.b_y_half[j] = np.exp(-(self.d_y_half[j] / self.K_y_half[j] + self.alpha_y_half[j]) * self.DELTAT)
            
            if abs(self.d_y[j]) > 1.0e-6:
                self.a_y[j] = self.d_y[j] * (self.b_y[j] - 1.0) / (self.K_y[j] * (self.d_y[j] + self.K_y[j] * self.alpha_y[j]))
            if abs(self.d_y_half[j]) > 1.0e-6:
                self.a_y_half[j] = self.d_y_half[j] * (self.b_y_half[j] - 1.0) / \
                                  (self.K_y_half[j] * (self.d_y_half[j] + self.K_y_half[j] * self.alpha_y_half[j]))

    def compute_stress(self):
        """Compute stress sigma and update memory variables"""
        
        # Compute stress for interior points
        for j in range(1, self.NY):
            for i in range(self.NX-1):
                value_dvx_dx = (self.vx[i+1,j] - self.vx[i,j]) / self.DELTAX
                value_dvy_dy = (self.vy[i,j] - self.vy[i,j-1]) / self.DELTAY
                
                self.memory_dvx_dx[i,j] = self.b_x_half[i] * self.memory_dvx_dx[i,j] + self.a_x_half[i] * value_dvx_dx
                self.memory_dvy_dy[i,j] = self.b_y[j] * self.memory_dvy_dy[i,j] + self.a_y[j] * value_dvy_dy
                
                value_dvx_dx = value_dvx_dx / self.K_x_half[i] + self.memory_dvx_dx[i,j]
                value_dvy_dy = value_dvy_dy / self.K_y[j] + self.memory_dvy_dy[i,j]
                
                self.sigmaxx[i,j] += (self.c11 * value_dvx_dx + self.c12 * value_dvy_dy) * self.DELTAT
                self.sigmayy[i,j] += (self.c12 * value_dvx_dx + self.c22 * value_dvy_dy) * self.DELTAT
        
        # Compute shear stress
        for j in range(self.NY-1):
            for i in range(1, self.NX):
                value_dvy_dx = (self.vy[i,j] - self.vy[i-1,j]) / self.DELTAX
                value_dvx_dy = (self.vx[i,j+1] - self.vx[i,j]) / self.DELTAY
                
                self.memory_dvy_dx[i,j] = self.b_x[i] * self.memory_dvy_dx[i,j] + self.a_x[i] * value_dvy_dx
                self.memory_dvx_dy[i,j] = self.b_y_half[j] * self.memory_dvx_dy[i,j] + self.a_y_half[j] * value_dvx_dy
                
                value_dvy_dx = value_dvy_dx / self.K_x[i] + self.memory_dvy_dx[i,j]
                value_dvx_dy = value_dvx_dy / self.K_y_half[j] + self.memory_dvx_dy[i,j]
                
                self.sigmaxy[i,j] += self.c33 * (value_dvy_dx + value_dvx_dy) * self.DELTAT

    def compute_velocity(self):
        """Compute velocity and update memory variables"""
        
        # Compute velocity components
        for j in range(1, self.NY):
            for i in range(1, self.NX):
                value_dsigmaxx_dx = (self.sigmaxx[i,j] - self.sigmaxx[i-1,j]) / self.DELTAX
                value_dsigmaxy_dy = (self.sigmaxy[i,j] - self.sigmaxy[i,j-1]) / self.DELTAY
                
                self.memory_dsigmaxx_dx[i,j] = self.b_x[i] * self.memory_dsigmaxx_dx[i,j] + self.a_x[i] * value_dsigmaxx_dx
                self.memory_dsigmaxy_dy[i,j] = self.b_y[j] * self.memory_dsigmaxy_dy[i,j] + self.a_y[j] * value_dsigmaxy_dy
                
                value_dsigmaxx_dx = value_dsigmaxx_dx / self.K_x[i] + self.memory_dsigmaxx_dx[i,j]
                value_dsigmaxy_dy = value_dsigmaxy_dy / self.K_y[j] + self.memory_dsigmaxy_dy[i,j]
                
                self.vx[i,j] += (value_dsigmaxx_dx + value_dsigmaxy_dy) * self.DELTAT / self.rho
        
        for j in range(self.NY-1):
            for i in range(self.NX-1):
                value_dsigmaxy_dx = (self.sigmaxy[i+1,j] - self.sigmaxy[i,j]) / self.DELTAX
                value_dsigmayy_dy = (self.sigmayy[i,j+1] - self.sigmayy[i,j]) / self.DELTAY
                
                self.memory_dsigmaxy_dx[i,j] = self.b_x_half[i] * self.memory_dsigmaxy_dx[i,j] + self.a_x_half[i] * value_dsigmaxy_dx
                self.memory_dsigmayy_dy[i,j] = self.b_y_half[j] * self.memory_dsigmayy_dy[i,j] + self.a_y_half[j] * value_dsigmayy_dy
                
                value_dsigmaxy_dx = value_dsigmaxy_dx / self.K_x_half[i] + self.memory_dsigmaxy_dx[i,j]
                value_dsigmayy_dy = value_dsigmayy_dy / self.K_y_half[j] + self.memory_dsigmayy_dy[i,j]
                
                self.vy[i,j] += (value_dsigmaxy_dx + value_dsigmayy_dy) * self.DELTAT / self.rho

    def add_source(self, it):
        """Add the source (force vector located at a given grid point)"""
        a = self.PI * self.PI * self.f0 * self.f0
        t = (it-1) * self.DELTAT
        
        # First derivative of a Gaussian
        source_term = -self.factor * 2.0 * a * (t-self.t0) * np.exp(-a*(t-self.t0)**2)
        
        force_x = np.sin(self.ANGLE_FORCE * self.DEGREES_TO_RADIANS) * source_term
        force_y = np.cos(self.ANGLE_FORCE * self.DEGREES_TO_RADIANS) * source_term
        
        # Define location of the source
        i = self.ISOURCE
        j = self.JSOURCE
        
        self.vx[i,j] += force_x * self.DELTAT / self.rho
        self.vy[i,j] += force_y * self.DELTAT / self.rho

    def apply_boundary_conditions(self):
        """Apply Dirichlet boundary conditions (rigid boundaries)"""
        # On the edges or at the bottom of the PML layers
        self.vx[0,:] = self.ZERO
        self.vx[-1,:] = self.ZERO
        self.vx[:,0] = self.ZERO
        self.vx[:,-1] = self.ZERO
        
        self.vy[0,:] = self.ZERO
        self.vy[-1,:] = self.ZERO
        self.vy[:,0] = self.ZERO
        self.vy[:,-1] = self.ZERO

    def simulate(self):
        """Run the main simulation"""
        
        # Check Courant stability condition
        quasi_cp_max = max(np.sqrt(self.c22/self.rho), np.sqrt(self.c11/self.rho))
        Courant_number = quasi_cp_max * self.DELTAT * np.sqrt(1.0/self.DELTAX**2 + 1.0/self.DELTAY**2)
        print(f'Courant number is {Courant_number}')
        if Courant_number > 1.0:
            raise ValueError('Time step is too large, simulation will be unstable')
        
        # Setup PML boundaries
        self.setup_pml_boundary()
        self.setup_pml_boundary_y()
        
        # Time stepping
        for it in range(1, self.NSTEP + 1):
            # Compute stress sigma and update memory variables
            self.compute_stress()
            
            # Compute velocity and update memory variables
            self.compute_velocity()
            
            # Add source
            self.add_source(it)
            
            # Apply Dirichlet boundary conditions
            self.apply_boundary_conditions()
            
            # Output information
            if it % self.IT_DISPLAY == 0 or it == 5:
                self.output_info(it)
        
        print("\nEnd of the simulation")

    def output_info(self, it):
        """Output information about the simulation status"""
        # Calculate maximum velocity norm
        velocnorm = np.max(np.sqrt(self.vx**2 + self.vy**2))
        print(f'Time step # {it} out of {self.NSTEP}')
        print(f'Time: {(it-1)*self.DELTAT:.6f} seconds')
        print(f'Max norm velocity vector V (m/s) = {velocnorm}')
        print()
        
        # Check stability
        if velocnorm > self.STABILITY_THRESHOLD:
            raise RuntimeError('code became unstable and blew up')
        
        # Create visualization
        self.create_color_image(self.vx, it, 1)
        self.create_color_image(self.vy, it, 2)

    def create_color_image(self, image_data_2D, it, field_number):
        """Create a color image of a given vector component"""
        # Parameters for visualization
        POWER_DISPLAY = 0.30  # non linear display to enhance small amplitudes
        cutvect = 0.01       # amplitude threshold above which we draw the color point
        WHITE_BACKGROUND = True
        width_cross = 5      # size of cross and square in pixels
        thickness_cross = 1
        
        # Create figure name based on field number
        if field_number == 1:
            field_name = 'Vx'
        else:
            field_name = 'Vy'
        
        fig_name = f'image{it:06d}_{field_name}.png'
        
        # Compute maximum amplitude
        max_amplitude = np.max(np.abs(image_data_2D))
        
        # Create RGB array for image
        img = np.zeros((self.NY, self.NX, 3))
        
        # Fill the image array
        for iy in range(self.NY-1, -1, -1):
            for ix in range(self.NX):
                # Normalize value to [-1,1]
                normalized_value = image_data_2D[ix,iy] / max_amplitude
                
                # Clip values to [-1,1]
                normalized_value = np.clip(normalized_value, -1.0, 1.0)
                
                # Draw source location
                if ((ix >= self.ISOURCE - width_cross and ix <= self.ISOURCE + width_cross and 
                     iy >= self.JSOURCE - thickness_cross and iy <= self.JSOURCE + thickness_cross) or
                    (ix >= self.ISOURCE - thickness_cross and ix <= self.ISOURCE + thickness_cross and
                     iy >= self.JSOURCE - width_cross and iy <= self.JSOURCE + width_cross)):
                    img[iy,ix] = [1.0, 0.616, 0.0]  # Orange
                
                # Draw frame
                elif ix <= 1 or ix >= self.NX-2 or iy <= 1 or iy >= self.NY-2:
                    img[iy,ix] = [0.0, 0.0, 0.0]  # Black
                
                # Draw PML boundaries
                elif ((self.USE_PML_XMIN and ix == self.NPOINTS_PML) or
                      (self.USE_PML_XMAX and ix == self.NX - self.NPOINTS_PML) or
                      (self.USE_PML_YMIN and iy == self.NPOINTS_PML) or
                      (self.USE_PML_YMAX and iy == self.NY - self.NPOINTS_PML)):
                    img[iy,ix] = [1.0, 0.588, 0.0]  # Orange-yellow
                
                # Values below threshold
                elif abs(image_data_2D[ix,iy]) <= max_amplitude * cutvect:
                    if WHITE_BACKGROUND:
                        img[iy,ix] = [1.0, 1.0, 1.0]  # White
                    else:
                        img[iy,ix] = [0.0, 0.0, 0.0]  # Black
                
                # Regular points
                else:
                    if normalized_value >= 0.0:
                        # Red for positive values
                        img[iy,ix] = [normalized_value**POWER_DISPLAY, 0.0, 0.0]
                    else:
                        # Blue for negative values
                        img[iy,ix] = [0.0, 0.0, abs(normalized_value)**POWER_DISPLAY]
        
        # Save the image
        plt.imsave(fig_name, img)
        
        # Optional: Display the image
        # plt.figure(figsize=(10,10))
        # plt.imshow(img)
        # plt.axis('off')
        # plt.show()

if __name__ == '__main__':
    simulator = SeismicCPML2DAniso()
    simulator.simulate()